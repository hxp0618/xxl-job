xxl-job项目源码下载以后，目录结构如下所示：

```text
xxl-job-admin：调度中心
xxl-job-core：公共依赖
xxl-job-executor-samples：执行器Sample示例（选择合适的版本执行器，可直接使用，也可以参考其并将现有项目改造成执行器）
    ：xxl-job-executor-sample-springboot：Springboot版本，通过Springboot管理执行器，推荐这种方式；
    ：xxl-job-executor-sample-frameless：无框架版本；
```

**xxl-job-admin模块是调度中心，用来管理调度任务。**

**xxl-job-core模块是公共的依赖，供调度中心以及调度任务依赖。**

**xxl-job-executor-samples是执行器案例，有两个执行器案例**
，xxl-job-executor-sample-springboot是spring版本。xxl-job-executor-sample-frameless是普通的版本，直接通过main方法启动。

在启动xxl-job，首先应该启动xxl-job-admin，然后启动执行案例的其中一个。xxl-job-admin是springboot项目，可以直接启动，具体启动方法直接参考官方的文档，非常的详细。今天要将的内容就是xxl-job-admin的启动流程分析。

在启动xxl-job-admin的过程中，XxlJobAdminConfig是配置类，在afterPropertiesSet方法中会创建调度器以及对调度器进行初始化。

```java
代码位置：com.xxl.job.admin.core.conf.XxlJobAdminConfig
public void afterPropertiesSet()throws Exception{
        adminConfig=this;

        //新建调度器
        xxlJobScheduler=new XxlJobScheduler();
        //调度器初始化
        xxlJobScheduler.init();
        }
```

xxlJobScheduler.init方法就是调度器的初始化方法，方法如下：

```java
//代码位置：com.xxl.job.admin.core.scheduler.XxlJobScheduler#init
public void init()throws Exception{
        // init i18n 初始化国际化
        initI18n();

        // admin trigger pool start 触发器线程池创建
        JobTriggerPoolHelper.toStart();

        // admin registry monitor run 注册监控器启动
        JobRegistryHelper.getInstance().start();

        // admin fail-monitor run  失败监控器启动
        JobFailMonitorHelper.getInstance().start();

        // admin lose-monitor run ( depend on JobTriggerPoolHelper )
        //丢失监控器启动
        JobCompleteHelper.getInstance().start();

        // admin log report start
        //日志报告启动
        JobLogReportHelper.getInstance().start();

        // start-schedule  ( depend on JobTriggerPoolHelper )
        //调度启动
        JobScheduleHelper.getInstance().start();

        logger.info(">>>>>>>>> init xxl-job admin success.");
        }
```

init()方法主要做了如下几件事：

- 国际化初始化
- 触发器线程池创建
- 注册监控器启动
- 失败监控器启动
- 丢失监控器启动
- 日志任务启动
- 调度启动

### 国际化初始化

```java
//代码位置：com.xxl.job.admin.core.scheduler.XxlJobScheduler#initI18n
private void initI18n(){
        for(ExecutorBlockStrategyEnum item:ExecutorBlockStrategyEnum.values()){
        item.setTitle(I18nUtil.getString("jobconf_block_".concat(item.name())));
        }
        }
```

ExecutorBlockStrategyEnum是执行阻塞策略枚举，主要有单机串行、丢弃后续调度、覆盖之前调度三种策略，initI18n方法就是设置执行策略的title值。I18nUtil.getString方法就是根据配置读取resources/il8n/目录下的其中一个文件，该目录下有message_en.properties、message_zh_CN.properties、message_zh_TC.properties三个文件，分别为英语、中文简体、中文繁体是属性文件。I18nUtil.getString方法获取到执行阻塞策略的值赋值给title.

### 触发器线程池创建

```java
//代码位置：com.xxl.job.admin.core.thread.JobTriggerPoolHelper
public void start(){
        //快速触发线程池
        fastTriggerPool=new ThreadPoolExecutor(
        10,
        XxlJobAdminConfig.getAdminConfig().getTriggerPoolFastMax(),
        60L,
        TimeUnit.SECONDS,
        new LinkedBlockingQueue<Runnable>(1000),
        new ThreadFactory(){
@Override
public Thread newThread(Runnable r){
        return new Thread(r,"xxl-job, admin JobTriggerPoolHelper-fastTriggerPool-"+r.hashCode());
        }
        });

        //慢速触发线程池
        slowTriggerPool=new ThreadPoolExecutor(
        10,
        XxlJobAdminConfig.getAdminConfig().getTriggerPoolSlowMax(),
        60L,
        TimeUnit.SECONDS,
        new LinkedBlockingQueue<Runnable>(2000),
        new ThreadFactory(){
@Override
public Thread newThread(Runnable r){
        return new Thread(r,"xxl-job, admin JobTriggerPoolHelper-slowTriggerPool-"+r.hashCode());
        }
        });
        }
```

触发器线程池创建调用了JobTriggerPoolHelper类的start方法，start方法创建了两个线程池、fastTriggerPool为快速线程池、slowTriggerPool为慢速线程池，都是采用阻塞队列LinkedBlockingQueue，快速线程池的阻塞队列大小为1000，慢速线程池的阻塞队列大小为2000。快速线程池、慢速线程池在什么时候被用来调度任务呢？**
默认是用快速调度器调度任务的，当缓存中等待被调度的同一个任务的数量大于10的时候，就用慢速调度器调度任务。**

### 注册监控器启动

```java
//代码位置：com.xxl.job.admin.core.thread.JobRegistryHelper#start
public void start(){

        // for registry or remove
        //调度任务注册线程池
        registryOrRemoveThreadPool=new ThreadPoolExecutor(
        2,
        10,
        30L,
        TimeUnit.SECONDS,
        new LinkedBlockingQueue<Runnable>(2000),
        new ThreadFactory(){
@Override
public Thread newThread(Runnable r){
        return new Thread(r,"xxl-job, admin JobRegistryMonitorHelper-registryOrRemoveThreadPool-"+r.hashCode());
        }
        },
        new RejectedExecutionHandler(){
@Override
public void rejectedExecution(Runnable r,ThreadPoolExecutor executor){
        r.run();
        logger.warn(">>>>>>>>>>> xxl-job, registry or remove too fast, match threadpool rejected handler(run now).");
        }
        });

        // for monitor
        //注册监控器线程
        registryMonitorThread=new Thread(new Runnable(){
@Override
public void run(){
        //代码省略
        }

        });
        registryMonitorThread.setDaemon(true);
        registryMonitorThread.setName("xxl-job, admin JobRegistryMonitorHelper-registryMonitorThread");
        registryMonitorThread.start();
        }
```

JobRegistryHelper的start创建了一个调度任务注册线程池registryOrRemoveThreadPool以及注册监控器线程registryMonitorThread，调度任务注册线程池用来执行调度任务的注册，注册监控器线程用来监控执行器的机器是否下线。然后将registryMonitorThread设置为守护线程，最后启动registryMonitorThread线程，开始监控执行器的机器。registryMonitorThread线程的run方法的代码被省略，接下来分析下run方法的具体逻辑：、

```java
public void run(){
        while(!toStop){
        try{
        // auto registry group
        //自动注册的执行器列表
        List<XxlJobGroup> groupList=XxlJobAdminConfig.getAdminConfig().getXxlJobGroupDao().findByAddressType(0);
        if(groupList!=null&&!groupList.isEmpty()){

        // remove dead address (admin/executor)
        //获取已经下线的机器地址记录
        List<Integer> ids=XxlJobAdminConfig.getAdminConfig().getXxlJobRegistryDao().findDead(RegistryConfig.DEAD_TIMEOUT,new Date());
        if(ids!=null&&ids.size()>0){
        //删除已经下线的注册
        XxlJobAdminConfig.getAdminConfig().getXxlJobRegistryDao().removeDead(ids);
        }

        // fresh online address (admin/executor)
        //刷新在线的机器
        HashMap<String, List<String>>appAddressMap=new HashMap<String, List<String>>();
        //查询存活的执行器注册机器
        List<XxlJobRegistry> list=XxlJobAdminConfig.getAdminConfig().getXxlJobRegistryDao().findAll(RegistryConfig.DEAD_TIMEOUT,new Date());
        if(list!=null){
        for(XxlJobRegistry item:list){
        //如果是执行器,将同一个应用的调度任务放在list中
        if(RegistryConfig.RegistType.EXECUTOR.name().equals(item.getRegistryGroup())){
        String appname=item.getRegistryKey();
        List<String> registryList=appAddressMap.get(appname);
        if(registryList==null){
        registryList=new ArrayList<String>();
        }

        if(!registryList.contains(item.getRegistryValue())){
        registryList.add(item.getRegistryValue());
        }
        appAddressMap.put(appname,registryList);
        }
        }
        }

        // fresh group address
        //遍历自动注册的执行器列表
        for(XxlJobGroup group:groupList){
        List<String> registryList=appAddressMap.get(group.getAppname());
        String addressListStr=null;
        if(registryList!=null&&!registryList.isEmpty()){
        Collections.sort(registryList);
        StringBuilder addressListSB=new StringBuilder();
        //执行器地址拼接
        for(String item:registryList){
        addressListSB.append(item).append(",");
        }
        addressListStr=addressListSB.toString();
        addressListStr=addressListStr.substring(0,addressListStr.length()-1);
        }
        //设置地址
        group.setAddressList(addressListStr);
        //设置注册更新时间
        group.setUpdateTime(new Date());

        //更新注册的执行器地址
        XxlJobAdminConfig.getAdminConfig().getXxlJobGroupDao().update(group);
        }
        }
        }catch(Exception e){
        if(!toStop){
        logger.error(">>>>>>>>>>> xxl-job, job registry monitor thread error:{}",e);
        }
        }
        try{
        TimeUnit.SECONDS.sleep(RegistryConfig.BEAT_TIMEOUT);
        }catch(InterruptedException e){
        if(!toStop){
        logger.error(">>>>>>>>>>> xxl-job, job registry monitor thread error:{}",e);
        }
        }
        }
        logger.info(">>>>>>>>>>> xxl-job, job registry monitor thread stop");
        }
```

run()
方法一直执行，直到服务停止，主要做了两件事，第一将已经下线的执行器的记录从数据库中删除，第二将还在线的执行器机器记录重新设置执行器地址以及更新执行器的时间，然后更新数据库的记录。怎么判定执行器已经下线了？如果数据库中的update_time字段小于当前时间减去死亡期限，那么说明已经执行器在死亡期限没有进行更新时间，就判定已经下线了。执行器在启动的时候，会启动一个执行器线程不断的执行注册任务，执行器任务会更新update_time字段。

### 失败监控器启动

```java
//代码位置：com.xxl.job.admin.core.thread.JobFailMonitorHelper#start
public void start(){
        monitorThread=new Thread(new Runnable(){

@Override
public void run(){
        //代码省略
        }
        });
        monitorThread.setDaemon(true);
        monitorThread.setName("xxl-job, admin JobFailMonitorHelper");
        monitorThread.start();
        }
```

上述代码创建了一个名字为monitorThread的线程，并设为守护线程，然后启动这个线程。线程的run方法的代码被省略，run方法的代码如下：

```java
public void run(){

        // monitor
        while(!toStop){
        try{

        //获取失败任务日志，最多1000条
        List<Long> failLogIds=XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().findFailJobLogIds(1000);
        if(failLogIds!=null&&!failLogIds.isEmpty()){
        //遍历失败日志
        for(long failLogId:failLogIds){

        // lock log
        //将默认（0）告警状态设置为锁定状态（-1）
        int lockRet=XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateAlarmStatus(failLogId,0,-1);
        if(lockRet< 1){
        continue;
        }
        XxlJobLog log=XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().load(failLogId);
        //获取任务信息
        XxlJobInfo info=XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().loadById(log.getJobId());

        // 1、fail retry monitor
        //如果失败重试次数大于0
        if(log.getExecutorFailRetryCount()>0){
        //触发任务执行
        JobTriggerPoolHelper.trigger(log.getJobId(),TriggerTypeEnum.RETRY,(log.getExecutorFailRetryCount()-1),log.getExecutorShardingParam(),log.getExecutorParam(),null);
        String retryMsg="<br><br><span style=\"color:#F39C12;\" > >>>>>>>>>>>"+I18nUtil.getString("jobconf_trigger_type_retry")+"<<<<<<<<<<< </span><br>";
        log.setTriggerMsg(log.getTriggerMsg()+retryMsg);
        //更新触发日志信息
        XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateTriggerInfo(log);
        }

        // 2、fail alarm monitor
        int newAlarmStatus=0;     // 告警状态：0-默认、-1=锁定状态、1-无需告警、2-告警成功、3-告警失败
        //如果告警邮件不为null
        if(info!=null&&info.getAlarmEmail()!=null&&info.getAlarmEmail().trim().length()>0){
        //告警
        boolean alarmResult=XxlJobAdminConfig.getAdminConfig().getJobAlarmer().alarm(info,log);
        newAlarmStatus=alarmResult?2:3;
        }else{
        newAlarmStatus=1;
        }

        //将锁定（-1）的日志更新为新的告警状态
        XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateAlarmStatus(failLogId,-1,newAlarmStatus);
        }
        }

        }catch(Exception e){
        if(!toStop){
        logger.error(">>>>>>>>>>> xxl-job, job fail monitor thread error:{}",e);
        }
        }

        try{
        TimeUnit.SECONDS.sleep(10);
        }catch(Exception e){
        if(!toStop){
        logger.error(e.getMessage(),e);
        }
        }

        }

        logger.info(">>>>>>>>>>> xxl-job, job fail monitor thread stop");

        }
```

run方法一直运行，直到线程停止。run方法的首先从数据库中获取失败的调度任务日志列表，每次最多一千条。遍历失败的调度任务日志列表，首先将失败的调度任务日志进行锁定，暂停给告警邮件发送告警信息。如果调度任务的失败重试次数大于0，触发任务执行，更新任务日志信息。当邮件不为空时，触发告警信息，最后将锁定的日志状态更新为告警状态。

### 日志任务启动

主要做了两件事：
第一，统计当前时间前三天的触发任务的数量、运行中的任务的数量、成功的任务数量、任务失败的数量，然后保存在数据库中。
第二，根据配置的保存日志的过期时间，将已经过期的日志从数据库中查出来，然后清理过期的日志。日志任务启动是创建了一个线程，然后一直在后台运行。

### 调度启动

调度启动创建了两个线程，一个线程是用于不断从数据库把5秒内要执行的任务读出，立即触发或者放到时间轮等待触发，一个是用于触发任务。这里先不详细讲解具体的源码，在下一篇文章中进行详细的分析。

### 总结

调用中心启动就是启动springboot项目。在启动的过程中加载XxlJobAdminConfig配置类，在配置类中，会进行一系列的初始化工作，加载配置信息，创建以及初始化一系列化线程在后台一直异步运行，提高了性能。
